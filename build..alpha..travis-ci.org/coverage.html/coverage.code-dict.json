{"/home/travis/build/npmtest/node-npmtest-docxtemplater/test.js":"/* istanbul instrument in package npmtest_docxtemplater */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-docxtemplater/lib.npmtest_docxtemplater.js":"/* istanbul instrument in package npmtest_docxtemplater */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_docxtemplater = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_docxtemplater = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-docxtemplater/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-docxtemplater && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_docxtemplater */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_docxtemplater\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_docxtemplater.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        local.assetsDict['/assets.npmtest_docxtemplater.rollup.js'] =\n            local.assetsDict['/assets.npmtest_docxtemplater.rollup.js'] ||\n            local.fs.readFileSync(\n                // buildCustomOrg-hack\n                local.npmtest_docxtemplater.__dirname +\n                    '/lib.npmtest_docxtemplater.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-docxtemplater/node_modules/docxtemplater/js/docxtemplater.js":"\"use strict\";\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar DocUtils = require(\"./doc-utils\");\nDocUtils.traits = require(\"./traits\");\nDocUtils.moduleWrapper = require(\"./module-wrapper\");\nvar wrapper = DocUtils.moduleWrapper;\n\nvar Docxtemplater = function () {\n\tfunction Docxtemplater() {\n\t\t_classCallCheck(this, Docxtemplater);\n\n\t\tif (arguments.length > 0) {\n\t\t\tthrow new Error(\"The constructor with parameters have been removed in docxtemplater 3.0, please check the upgrade guide.\");\n\t\t}\n\t\tthis.compiled = {};\n\t\tthis.modules = [];\n\t\tthis.setOptions({});\n\t}\n\n\t_createClass(Docxtemplater, [{\n\t\tkey: \"attachModule\",\n\t\tvalue: function attachModule(module) {\n\t\t\tthis.modules.push(wrapper(module));\n\t\t\treturn this;\n\t\t}\n\t}, {\n\t\tkey: \"setOptions\",\n\t\tvalue: function setOptions(options) {\n\t\t\tvar _this = this;\n\n\t\t\tthis.options = options;\n\t\t\tObject.keys(DocUtils.defaults).forEach(function (key) {\n\t\t\t\tvar defaultValue = DocUtils.defaults[key];\n\t\t\t\t_this[key] = _this.options[key] != null ? _this.options[key] : defaultValue;\n\t\t\t});\n\t\t\tif (this.zip) {\n\t\t\t\tthis.updateFileTypeConfig();\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\t}, {\n\t\tkey: \"loadZip\",\n\t\tvalue: function loadZip(zip) {\n\t\t\tif (zip.loadAsync) {\n\t\t\t\tthrow new Error(\"Docxtemplater doesn't handle JSZip version >=3, see changelog\");\n\t\t\t}\n\t\t\tthis.zip = zip;\n\t\t\tthis.updateFileTypeConfig();\n\t\t\treturn this;\n\t\t}\n\t}, {\n\t\tkey: \"compileFile\",\n\t\tvalue: function compileFile(fileName) {\n\t\t\tvar currentFile = this.createTemplateClass(fileName);\n\t\t\tcurrentFile.parse();\n\t\t\tthis.compiled[fileName] = currentFile;\n\t\t}\n\t}, {\n\t\tkey: \"compile\",\n\t\tvalue: function compile() {\n\t\t\tthis.templatedFiles = this.fileTypeConfig.getTemplatedFiles(this.zip);\n\t\t\treturn this;\n\t\t}\n\t}, {\n\t\tkey: \"updateFileTypeConfig\",\n\t\tvalue: function updateFileTypeConfig() {\n\t\t\tthis.fileType = this.zip.files[\"word/document.xml\"] ? \"docx\" : \"pptx\";\n\t\t\tthis.fileTypeConfig = this.options.fileTypeConfig || Docxtemplater.FileTypeConfig[this.fileType];\n\t\t\treturn this;\n\t\t}\n\t}, {\n\t\tkey: \"render\",\n\t\tvalue: function render() {\n\t\t\tvar _this2 = this;\n\n\t\t\tthis.options.xmlFileNames = [];\n\t\t\tthis.modules = this.fileTypeConfig.baseModules.map(function (moduleFunction) {\n\t\t\t\treturn moduleFunction();\n\t\t\t}).concat(this.modules);\n\t\t\tthis.options = this.modules.reduce(function (options, module) {\n\t\t\t\treturn module.optionsTransformer(options, _this2);\n\t\t\t}, this.options);\n\t\t\tthis.xmlDocuments = this.options.xmlFileNames.reduce(function (xmlDocuments, fileName) {\n\t\t\t\tvar content = _this2.zip.files[fileName].asText();\n\t\t\t\txmlDocuments[fileName] = DocUtils.str2xml(content);\n\t\t\t\treturn xmlDocuments;\n\t\t\t}, {});\n\t\t\tthis.modules.forEach(function (module) {\n\t\t\t\tmodule.set({ zip: _this2.zip, xmlDocuments: _this2.xmlDocuments, data: _this2.data });\n\t\t\t});\n\t\t\tthis.compile();\n\n\t\t\tthis.modules.forEach(function (module) {\n\t\t\t\tmodule.set({ compiled: _this2.compiled });\n\t\t\t});\n\t\t\t// Loop inside all templatedFiles (ie xml files with content).\n\t\t\t// Sometimes they don't exist (footer.xml for example)\n\t\t\tthis.templatedFiles.forEach(function (fileName) {\n\t\t\t\tif (_this2.zip.files[fileName] != null) {\n\t\t\t\t\t_this2.compileFile(fileName);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tthis.mapper = this.modules.reduce(function (value, module) {\n\t\t\t\treturn module.getRenderedMap(value);\n\t\t\t}, {});\n\n\t\t\tObject.keys(this.mapper).forEach(function (to) {\n\t\t\t\tvar mapped = _this2.mapper[to];\n\t\t\t\tvar from = mapped.from;\n\t\t\t\tvar currentFile = _this2.compiled[from];\n\t\t\t\tcurrentFile.setTags(mapped.data);\n\t\t\t\tcurrentFile.render(to);\n\t\t\t\t_this2.zip.file(to, currentFile.content);\n\t\t\t});\n\n\t\t\tObject.keys(this.xmlDocuments).forEach(function (fileName) {\n\t\t\t\t_this2.zip.remove(fileName);\n\t\t\t\tvar content = DocUtils.xml2str(_this2.xmlDocuments[fileName]);\n\t\t\t\treturn _this2.zip.file(fileName, content, {});\n\t\t\t});\n\t\t\treturn this;\n\t\t}\n\t}, {\n\t\tkey: \"setData\",\n\t\tvalue: function setData(data) {\n\t\t\tthis.data = data;\n\t\t\treturn this;\n\t\t}\n\t}, {\n\t\tkey: \"getZip\",\n\t\tvalue: function getZip() {\n\t\t\treturn this.zip;\n\t\t}\n\t}, {\n\t\tkey: \"createTemplateClass\",\n\t\tvalue: function createTemplateClass(path) {\n\t\t\tvar usedData = this.zip.files[path].asText();\n\t\t\treturn this.createTemplateClassFromContent(usedData, path);\n\t\t}\n\t}, {\n\t\tkey: \"createTemplateClassFromContent\",\n\t\tvalue: function createTemplateClassFromContent(content, filePath) {\n\t\t\tvar _this3 = this;\n\n\t\t\tvar xmltOptions = {\n\t\t\t\tfilePath: filePath\n\t\t\t};\n\t\t\tObject.keys(DocUtils.defaults).forEach(function (key) {\n\t\t\t\txmltOptions[key] = _this3[key];\n\t\t\t});\n\t\t\txmltOptions.fileTypeConfig = this.fileTypeConfig;\n\t\t\txmltOptions.modules = this.modules;\n\t\t\treturn new Docxtemplater.XmlTemplater(content, xmltOptions);\n\t\t}\n\t}, {\n\t\tkey: \"getFullText\",\n\t\tvalue: function getFullText(path) {\n\t\t\treturn this.createTemplateClass(path || this.fileTypeConfig.textPath).getFullText();\n\t\t}\n\t}, {\n\t\tkey: \"getTemplatedFiles\",\n\t\tvalue: function getTemplatedFiles() {\n\t\t\tthis.compile();\n\t\t\treturn this.templatedFiles;\n\t\t}\n\t}]);\n\n\treturn Docxtemplater;\n}();\n\nDocxtemplater.DocUtils = require(\"./doc-utils\");\nDocxtemplater.Errors = require(\"./errors\");\nDocxtemplater.XmlTemplater = require(\"./xml-templater\");\nDocxtemplater.FileTypeConfig = require(\"./file-type-config\");\nDocxtemplater.XmlMatcher = require(\"./xml-matcher\");\nmodule.exports = Docxtemplater;","/home/travis/build/npmtest/node-npmtest-docxtemplater/node_modules/docxtemplater/js/doc-utils.js":"\"use strict\";\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nvar memoize = require(\"./memoize\");\nvar DOMParser = require(\"xmldom\").DOMParser;\nvar XMLSerializer = require(\"xmldom\").XMLSerializer;\nvar Errors = require(\"./errors\");\n\nvar DocUtils = {};\n\nfunction parser(tag) {\n\treturn _defineProperty({}, \"get\", function get(scope) {\n\t\tif (tag === \".\") {\n\t\t\treturn scope;\n\t\t}\n\t\treturn scope[tag];\n\t});\n}\n\nDocUtils.defaults = {\n\tnullGetter: function nullGetter(part) {\n\t\tif (!part.module) {\n\t\t\treturn \"undefined\";\n\t\t}\n\t\tif (part.module === \"rawxml\") {\n\t\t\treturn \"\";\n\t\t}\n\t\treturn \"\";\n\t},\n\n\tparser: memoize(parser),\n\tdelimiters: {\n\t\tstart: \"{\",\n\t\tend: \"}\"\n\t}\n};\n\nDocUtils.mergeObjects = function () {\n\tvar resObj = {};\n\tvar obj = void 0,\n\t    keys = void 0;\n\tfor (var i = 0; i < arguments.length; i += 1) {\n\t\tobj = arguments[i];\n\t\tkeys = Object.keys(obj);\n\t\tfor (var j = 0; j < keys.length; j += 1) {\n\t\t\tresObj[keys[j]] = obj[keys[j]];\n\t\t}\n\t}\n\treturn resObj;\n};\n\nDocUtils.xml2str = function (xmlNode) {\n\tvar a = new XMLSerializer();\n\treturn a.serializeToString(xmlNode);\n};\n\nDocUtils.decodeUtf8 = function (s) {\n\ttry {\n\t\tif (s === undefined) {\n\t\t\treturn undefined;\n\t\t}\n\t\t// replace Ascii 160 space by the normal space, Ascii 32\n\t\treturn decodeURIComponent(escape(DocUtils.convertSpaces(s)));\n\t} catch (e) {\n\t\tvar err = new Error(\"End\");\n\t\terr.properties.data = s;\n\t\terr.properties.explanation = \"Could not decode string to UTF8\";\n\t\tthrow err;\n\t}\n};\n\nDocUtils.encodeUtf8 = function (s) {\n\treturn unescape(encodeURIComponent(s));\n};\n\nDocUtils.str2xml = function (str, errorHandler) {\n\tvar parser = new DOMParser({ errorHandler: errorHandler });\n\treturn parser.parseFromString(str, \"text/xml\");\n};\n\nDocUtils.charMap = {\n\t\"&\": \"&amp;\",\n\t\"'\": \"&apos;\",\n\t\"<\": \"&lt;\",\n\t\">\": \"&gt;\"\n};\n\nvar regexStripRegexp = /[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g;\nDocUtils.escapeRegExp = function (str) {\n\treturn str.replace(regexStripRegexp, \"\\\\$&\");\n};\n\nDocUtils.charMapRegexes = Object.keys(DocUtils.charMap).map(function (endChar) {\n\tvar startChar = DocUtils.charMap[endChar];\n\treturn {\n\t\trstart: new RegExp(DocUtils.escapeRegExp(startChar), \"g\"),\n\t\trend: new RegExp(DocUtils.escapeRegExp(endChar), \"g\"),\n\t\tstart: startChar,\n\t\tend: endChar\n\t};\n});\n\nDocUtils.wordToUtf8 = function (string) {\n\tvar r = void 0;\n\tfor (var i = 0, l = DocUtils.charMapRegexes.length; i < l; i++) {\n\t\tr = DocUtils.charMapRegexes[i];\n\t\tstring = string.replace(r.rstart, r.end);\n\t}\n\treturn string;\n};\n\nDocUtils.utf8ToWord = function (string) {\n\tif (typeof string !== \"string\") {\n\t\tstring = string.toString();\n\t}\n\tvar r = void 0;\n\tfor (var i = 0, l = DocUtils.charMapRegexes.length; i < l; i++) {\n\t\tr = DocUtils.charMapRegexes[i];\n\t\tstring = string.replace(r.rend, r.start);\n\t}\n\treturn string;\n};\n\nDocUtils.cloneDeep = function (obj) {\n\treturn JSON.parse(JSON.stringify(obj));\n};\n\nDocUtils.concatArrays = function (arrays) {\n\treturn arrays.reduce(function (result, array) {\n\t\tArray.prototype.push.apply(result, array);\n\t\treturn result;\n\t}, []);\n};\n\nvar spaceRegexp = new RegExp(String.fromCharCode(160), \"g\");\nDocUtils.convertSpaces = function (s) {\n\treturn s.replace(spaceRegexp, \" \");\n};\n\nDocUtils.pregMatchAll = function (regex, content) {\n\t/* regex is a string, content is the content. It returns an array of all matches with their offset, for example:\n \t regex=la\n \t content=lolalolilala\n returns: [{array: {0: 'la'},offset: 2},{array: {0: 'la'},offset: 8},{array: {0: 'la'} ,offset: 10}]\n */\n\tvar matchArray = [];\n\tvar match = void 0;\n\twhile ((match = regex.exec(content)) != null) {\n\t\tmatchArray.push({ array: match, offset: match.index });\n\t}\n\treturn matchArray;\n};\n\nDocUtils.sizeOfObject = function (obj) {\n\treturn Object.keys(obj).length;\n};\n\nfunction throwXmlTagNotFound(options) {\n\tvar err = new Errors.XTTemplateError(\"No tag '\" + options.element + \"' was found at the \" + options.position);\n\terr.properties = {\n\t\tid: \"no_xml_tag_found_at_\" + options.position,\n\t\texplanation: \"No tag '\" + options.element + \"' was found at the \" + options.position,\n\t\tparsed: options.parsed,\n\t\tindex: options.index,\n\t\telement: options.element\n\t};\n\tthrow err;\n}\n\nDocUtils.getRight = function (parsed, element, index) {\n\tfor (var i = index, l = parsed.length; i < l; i++) {\n\t\tvar part = parsed[i];\n\t\tif (part.value === \"</\" + element + \">\") {\n\t\t\treturn i;\n\t\t}\n\t}\n\tthrowXmlTagNotFound({ position: \"right\", element: element, parsed: parsed, index: index });\n};\n\nDocUtils.getLeft = function (parsed, element, index) {\n\tfor (var i = index; i >= 0; i--) {\n\t\tvar part = parsed[i];\n\t\tif (part.value.indexOf(\"<\" + element) === 0 && [\">\", \" \"].indexOf(part.value[element.length + 1]) !== -1) {\n\t\t\treturn i;\n\t\t}\n\t}\n\tthrowXmlTagNotFound({ position: \"left\", element: element, parsed: parsed, index: index });\n};\n\nmodule.exports = DocUtils;","/home/travis/build/npmtest/node-npmtest-docxtemplater/node_modules/docxtemplater/js/memoize.js":"\"use strict\";\n\nfunction memoize(func) {\n\tvar stringifyJson = JSON.stringify,\n\t    cache = {};\n\tfunction cachedfun() {\n\t\tvar hash = stringifyJson(arguments);\n\t\treturn hash in cache ? cache[hash] : cache[hash] = func.apply(this, arguments);\n\t}\n\treturn cachedfun;\n}\n\nmodule.exports = memoize;","/home/travis/build/npmtest/node-npmtest-docxtemplater/node_modules/docxtemplater/js/errors.js":"\"use strict\";\n\nfunction XTError(message) {\n\tthis.name = \"GenericError\";\n\tthis.message = message;\n\tthis.stack = new Error(message).stack;\n}\nXTError.prototype = Error.prototype;\n\nfunction XTTemplateError(message) {\n\tthis.name = \"TemplateError\";\n\tthis.message = message;\n\tthis.stack = new Error(message).stack;\n}\nXTTemplateError.prototype = new XTError();\n\nfunction XTScopeParserError(message) {\n\tthis.name = \"ScopeParserError\";\n\tthis.message = message;\n\tthis.stack = new Error(message).stack;\n}\nXTScopeParserError.prototype = new XTError();\n\nfunction XTInternalError(message) {\n\tthis.name = \"InternalError\";\n\tthis.properties = { explanation: \"InternalError\" };\n\tthis.message = message;\n\tthis.stack = new Error(message).stack;\n}\nXTInternalError.prototype = new XTError();\n\nmodule.exports = {\n\tXTError: XTError,\n\tXTTemplateError: XTTemplateError,\n\tXTInternalError: XTInternalError,\n\tXTScopeParserError: XTScopeParserError\n};","/home/travis/build/npmtest/node-npmtest-docxtemplater/node_modules/docxtemplater/js/traits.js":"\"use strict\";\n\nvar DocUtils = require(\"./doc-utils\");\nvar Errors = require(\"./errors\");\n\nfunction throwRawTagNotInParagraph(options) {\n\tvar err = new Errors.XTTemplateError(\"Raw tag not in paragraph\");\n\tvar tag = options.part.value;\n\terr.properties = {\n\t\tid: \"raw_tag_outerxml_invalid\",\n\t\texplanation: \"The tag \\\"\" + tag + \"\\\"\",\n\t\trootError: options.rootError,\n\t\txtag: tag,\n\t\tpostparsed: options.postparsed,\n\t\texpandTo: options.expandTo,\n\t\tindex: options.index\n\t};\n\tthrow err;\n}\n\nfunction lastTagIsOpenTag(array, tag) {\n\tif (array.length === 0) {\n\t\treturn false;\n\t}\n\tvar lastTag = array[array.length - 1];\n\tvar innerLastTag = lastTag.tag.substr(1);\n\tvar innerCurrentTag = tag.substr(2, tag.length - 3);\n\treturn innerLastTag.indexOf(innerCurrentTag) === 0;\n}\n\nfunction addTag(array, tag) {\n\tarray.push({ tag: tag });\n\treturn array;\n}\n\nfunction getListXmlElements(parts) {\n\t/*\n get the different closing and opening tags between two texts (doesn't take into account tags that are opened then closed (those that are closed then opened are returned)):\n returns:[{\"tag\":\"</w:r>\",\"offset\":13},{\"tag\":\"</w:p>\",\"offset\":265},{\"tag\":\"</w:tc>\",\"offset\":271},{\"tag\":\"<w:tc>\",\"offset\":828},{\"tag\":\"<w:p>\",\"offset\":883},{\"tag\":\"<w:r>\",\"offset\":1483}]\n */\n\tvar tags = parts.filter(function (part) {\n\t\treturn part.type === \"tag\";\n\t}).map(function (part) {\n\t\treturn part.value;\n\t});\n\n\tvar result = [];\n\n\tfor (var i = 0, tag; i < tags.length; i++) {\n\t\ttag = tags[i];\n\t\t// closing tag\n\t\tif (tag[1] === \"/\") {\n\t\t\tif (lastTagIsOpenTag(result, tag)) {\n\t\t\t\tresult.pop();\n\t\t\t} else {\n\t\t\t\tresult = addTag(result, tag);\n\t\t\t}\n\t\t} else if (tag[tag.length - 1] !== \"/\") {\n\t\t\tresult = addTag(result, tag);\n\t\t}\n\t}\n\treturn result;\n}\n\nfunction getExpandToDefault(parts) {\n\tvar xmlElements = getListXmlElements(parts);\n\tfor (var i = 0; i < xmlElements.length; i++) {\n\t\tvar xmlElement = xmlElements[i];\n\t\tif (xmlElement.tag.indexOf(\"<w:tc\") === 0) {\n\t\t\treturn \"w:tr\";\n\t\t}\n\t\tif (xmlElement.tag.indexOf(\"<a:tc\") === 0) {\n\t\t\treturn \"a:tr\";\n\t\t}\n\t}\n\treturn false;\n}\n\nfunction expandOne(part, postparsed, options) {\n\tvar expandTo = part.expandTo || options.expandTo;\n\tvar index = postparsed.indexOf(part);\n\tif (!expandTo) {\n\t\treturn postparsed;\n\t}\n\tvar right = void 0,\n\t    left = void 0;\n\ttry {\n\t\tright = DocUtils.getRight(postparsed, expandTo, index);\n\t\tleft = DocUtils.getLeft(postparsed, expandTo, index);\n\t} catch (rootError) {\n\t\tif (rootError instanceof Errors.XTTemplateError) {\n\t\t\tthrowRawTagNotInParagraph({ part: part, rootError: rootError, postparsed: postparsed, expandTo: expandTo, index: index });\n\t\t}\n\t\tthrow rootError;\n\t}\n\tvar leftParts = postparsed.slice(left, index);\n\tvar rightParts = postparsed.slice(index + 1, right + 1);\n\tvar inner = options.getInner({ index: index, part: part, leftParts: leftParts, rightParts: rightParts, left: left, right: right, postparsed: postparsed });\n\tif (!inner.length) {\n\t\tinner.expanded = [leftParts, rightParts];\n\t\tinner = [inner];\n\t}\n\treturn DocUtils.concatArrays([postparsed.slice(0, left), inner, postparsed.slice(right + 1)]);\n}\n\nfunction expandToOne(postparsed, options) {\n\tvar expandToElements = postparsed.reduce(function (elements, part) {\n\t\tif (part.type === \"placeholder\" && part.module === options.moduleName) {\n\t\t\telements.push(part);\n\t\t}\n\t\treturn elements;\n\t}, []);\n\n\texpandToElements.forEach(function (part) {\n\t\tpostparsed = expandOne(part, postparsed, options);\n\t});\n\treturn postparsed;\n}\n\nmodule.exports = {\n\texpandToOne: expandToOne,\n\tgetExpandToDefault: getExpandToDefault\n};","/home/travis/build/npmtest/node-npmtest-docxtemplater/node_modules/docxtemplater/js/module-wrapper.js":"\"use strict\";\n\nfunction emptyFun() {}\nfunction identity(i) {\n\treturn i;\n}\nmodule.exports = function (module) {\n\tvar defaults = {\n\t\tset: emptyFun,\n\t\tparse: emptyFun,\n\t\trender: emptyFun,\n\t\tgetTraits: emptyFun,\n\t\toptionsTransformer: identity,\n\t\tgetRenderedMap: identity,\n\t\tpostparse: identity\n\t};\n\tif (Object.keys(defaults).every(function (key) {\n\t\treturn !module[key];\n\t})) {\n\t\tthrow new Error(\"This module cannot be wrapped, because it doesn't define any of the necessary functions\");\n\t}\n\tObject.keys(defaults).forEach(function (key) {\n\t\tmodule[key] = module[key] || defaults[key];\n\t});\n\treturn module;\n};","/home/travis/build/npmtest/node-npmtest-docxtemplater/node_modules/docxtemplater/js/xml-templater.js":"\"use strict\";\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar DocUtils = require(\"./doc-utils\");\nvar ScopeManager = require(\"./scope-manager\");\nvar xmlMatcher = require(\"./xml-matcher\");\nvar Errors = require(\"./errors\");\nvar Lexer = require(\"./lexer\");\nvar Parser = require(\"./parser.js\");\nvar _render = require(\"./render.js\");\n\nfunction _getFullText(content, tagsXmlArray) {\n\tvar matcher = xmlMatcher(content, tagsXmlArray);\n\tvar result = matcher.matches.map(function (match) {\n\t\treturn match.array[2];\n\t});\n\treturn DocUtils.wordToUtf8(DocUtils.convertSpaces(result.join(\"\")));\n}\n\nmodule.exports = function () {\n\tfunction XmlTemplater(content, options) {\n\t\t_classCallCheck(this, XmlTemplater);\n\n\t\tthis.fromJson(options);\n\t\tthis.setModules({ inspect: { filePath: this.filePath } });\n\t\tthis.load(content);\n\t}\n\n\t_createClass(XmlTemplater, [{\n\t\tkey: \"load\",\n\t\tvalue: function load(content) {\n\t\t\tif (typeof content !== \"string\") {\n\t\t\t\tvar err = new Errors.XTInternalError(\"Content must be a string\");\n\t\t\t\terr.properties.id = \"xmltemplater_content_must_be_string\";\n\t\t\t\tthrow err;\n\t\t\t}\n\t\t\tthis.content = content;\n\t\t}\n\t}, {\n\t\tkey: \"setTags\",\n\t\tvalue: function setTags(tags) {\n\t\t\tthis.tags = tags != null ? tags : {};\n\t\t\tthis.scopeManager = ScopeManager.createBaseScopeManager({ tags: this.tags, parser: this.parser });\n\t\t\treturn this;\n\t\t}\n\t}, {\n\t\tkey: \"fromJson\",\n\t\tvalue: function fromJson(options) {\n\t\t\tthis.filePath = options.filePath;\n\t\t\tthis.modules = options.modules;\n\t\t\tthis.fileTypeConfig = options.fileTypeConfig;\n\t\t\tObject.keys(DocUtils.defaults).map(function (key) {\n\t\t\t\tthis[key] = options[key] != null ? options[key] : DocUtils.defaults[key];\n\t\t\t}, this);\n\t\t}\n\t}, {\n\t\tkey: \"getFullText\",\n\t\tvalue: function getFullText() {\n\t\t\treturn _getFullText(this.content, this.fileTypeConfig.tagsXmlTextArray);\n\t\t}\n\t}, {\n\t\tkey: \"setModules\",\n\t\tvalue: function setModules(obj) {\n\t\t\tthis.modules.forEach(function (module) {\n\t\t\t\tmodule.set(obj);\n\t\t\t});\n\t\t}\n\t}, {\n\t\tkey: \"parse\",\n\t\tvalue: function parse() {\n\t\t\tthis.xmllexed = Lexer.xmlparse(this.content, { text: this.fileTypeConfig.tagsXmlTextArray, other: this.fileTypeConfig.tagsXmlLexedArray });\n\t\t\tthis.setModules({ inspect: { xmllexed: this.xmllexed } });\n\t\t\tthis.lexed = Lexer.parse(this.xmllexed, this.delimiters);\n\t\t\tthis.setModules({ inspect: { lexed: this.lexed } });\n\t\t\tthis.parsed = Parser.parse(this.lexed, this.modules);\n\t\t\tthis.setModules({ inspect: { parsed: this.parsed } });\n\t\t\tthis.postparsed = Parser.postparse(this.parsed, this.modules);\n\t\t\treturn this;\n\t\t}\n\t\t/*\n  content is the whole content to be tagged\n  scope is the current scope\n  returns the new content of the tagged content\n  */\n\n\t}, {\n\t\tkey: \"render\",\n\t\tvalue: function render(to) {\n\t\t\tthis.filePath = to;\n\t\t\tthis.setModules({ inspect: { postparsed: this.postparsed } });\n\t\t\tthis.content = _render({\n\t\t\t\tcompiled: this.postparsed,\n\t\t\t\ttags: this.tags,\n\t\t\t\tmodules: this.modules,\n\t\t\t\tparser: this.parser,\n\t\t\t\tnullGetter: this.nullGetter,\n\t\t\t\tfilePath: this.filePath\n\t\t\t});\n\t\t\tthis.setModules({ inspect: { content: this.content } });\n\t\t\treturn this;\n\t\t}\n\t}]);\n\n\treturn XmlTemplater;\n}();","/home/travis/build/npmtest/node-npmtest-docxtemplater/node_modules/docxtemplater/js/scope-manager.js":"\"use strict\";\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Errors = require(\"./errors\");\n\n// This class responsibility is to manage the scope\nvar ScopeManager = function () {\n\tfunction ScopeManager(options) {\n\t\t_classCallCheck(this, ScopeManager);\n\n\t\tthis.scopePath = options.scopePath;\n\t\tthis.scopeList = options.scopeList;\n\t\tthis.parser = options.parser;\n\t}\n\n\t_createClass(ScopeManager, [{\n\t\tkey: \"loopOver\",\n\t\tvalue: function loopOver(tag, callback, inverted) {\n\t\t\tinverted = inverted || false;\n\t\t\treturn this.loopOverValue(this.getValue(tag), callback, inverted);\n\t\t}\n\t}, {\n\t\tkey: \"functorIfInverted\",\n\t\tvalue: function functorIfInverted(inverted, functor, value) {\n\t\t\tif (inverted) {\n\t\t\t\tfunctor(value);\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: \"isValueFalsy\",\n\t\tvalue: function isValueFalsy(value, type) {\n\t\t\treturn value == null || !value || type === \"[object Array]\" && value.length === 0;\n\t\t}\n\t}, {\n\t\tkey: \"loopOverValue\",\n\t\tvalue: function loopOverValue(value, functor, inverted) {\n\t\t\tvar type = Object.prototype.toString.call(value);\n\t\t\tvar currentValue = this.scopeList[this.num];\n\t\t\tif (this.isValueFalsy(value, type)) {\n\t\t\t\treturn this.functorIfInverted(inverted, functor, currentValue);\n\t\t\t}\n\t\t\tif (type === \"[object Array]\") {\n\t\t\t\tfor (var i = 0, scope; i < value.length; i++) {\n\t\t\t\t\tscope = value[i];\n\t\t\t\t\tthis.functorIfInverted(!inverted, functor, scope);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (type === \"[object Object]\") {\n\t\t\t\treturn this.functorIfInverted(!inverted, functor, value);\n\t\t\t}\n\t\t\tif (value === true) {\n\t\t\t\treturn this.functorIfInverted(!inverted, functor, currentValue);\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: \"getValue\",\n\t\tvalue: function getValue(tag, num) {\n\t\t\t// search in the scopes (in reverse order) and keep the first defined value\n\t\t\tthis.num = num == null ? this.scopeList.length - 1 : num;\n\t\t\tvar err = void 0;\n\t\t\tvar parser = void 0;\n\t\t\tvar result = void 0;\n\t\t\tvar scope = this.scopeList[this.num];\n\t\t\ttry {\n\t\t\t\tparser = this.parser(tag);\n\t\t\t} catch (error) {\n\t\t\t\terr = new Errors.XTScopeParserError(\"Scope parser compilation failed\");\n\t\t\t\terr.properties = {\n\t\t\t\t\tid: \"scopeparser_compilation_failed\",\n\t\t\t\t\ttag: tag,\n\t\t\t\t\texplanation: \"The scope parser for the tag \" + tag + \" failed to compile\",\n\t\t\t\t\trootError: error\n\t\t\t\t};\n\t\t\t\tthrow err;\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tresult = parser.get(scope, { num: this.num, scopeList: this.scopeList });\n\t\t\t} catch (error) {\n\t\t\t\terr = new Errors.XTScopeParserError(\"Scope parser execution failed\");\n\t\t\t\terr.properties = {\n\t\t\t\t\tid: \"scopeparser_execution_failed\",\n\t\t\t\t\texplanation: \"The scope parser for the tag \" + tag + \" failed to execute\",\n\t\t\t\t\tscope: scope,\n\t\t\t\t\ttag: tag,\n\t\t\t\t\trootError: error\n\t\t\t\t};\n\t\t\t\tthrow err;\n\t\t\t}\n\t\t\tif (result == null && this.num > 0) {\n\t\t\t\treturn this.getValue(tag, this.num - 1);\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t}, {\n\t\tkey: \"createSubScopeManager\",\n\t\tvalue: function createSubScopeManager(scope, tag) {\n\t\t\tvar options = {\n\t\t\t\tscopePath: this.scopePath.slice(0),\n\t\t\t\tscopeList: this.scopeList.slice(0)\n\t\t\t};\n\n\t\t\toptions.parser = this.parser;\n\t\t\toptions.scopeList = this.scopeList.concat(scope);\n\t\t\toptions.scopePath = this.scopePath.concat(tag);\n\t\t\treturn new ScopeManager(options);\n\t\t}\n\t}]);\n\n\treturn ScopeManager;\n}();\n\nScopeManager.createBaseScopeManager = function (_ref) {\n\tvar parser = _ref.parser,\n\t    tags = _ref.tags;\n\n\tvar options = { parser: parser, tags: tags };\n\toptions.scopePath = [];\n\toptions.scopeList = [tags];\n\treturn new ScopeManager(options);\n};\n\nmodule.exports = ScopeManager;","/home/travis/build/npmtest/node-npmtest-docxtemplater/node_modules/docxtemplater/js/xml-matcher.js":"\"use strict\";\n// res class responsibility is to parse the XML.\n\nvar DocUtils = require(\"./doc-utils\");\nvar memoize = require(\"./memoize\");\n\nfunction handleRecursiveCase(res) {\n\t/*\n \t Because xmlTemplater is recursive (meaning it can call it self), we need to handle special cases where the XML is not valid:\n \t For example with res string \"I am</w:t></w:r></w:p><w:p><w:r><w:t>sleeping\",\n \t - we need to match also the string that is inside an implicit <w:t> (that's the role of replacerUnshift) (in res case 'I am')\n \t - we need to match the string that is at the right of a <w:t> (that's the role of replacerPush) (in res case 'sleeping')\n \t the test: describe \"scope calculation\" it \"should compute the scope between 2 <w:t>\" makes sure that res part of code works\n \t It should even work if they is no XML at all, for example if the code is just \"I am sleeping\", in res case however, they should only be one match\n \t */\n\n\tfunction replacerUnshift() {\n\t\tvar pn = { array: Array.prototype.slice.call(arguments) };\n\t\tpn.array.shift();\n\t\tvar match = pn.array[0] + pn.array[1];\n\t\t// add match so that pn[0] = whole match, pn[1]= first parenthesis,...\n\t\tpn.array.unshift(match);\n\t\tpn.array.pop();\n\t\tvar offset = pn.array.pop();\n\t\tpn.offset = offset;\n\t\tpn.first = true;\n\t\t// add at the beginning\n\t\tres.matches.unshift(pn);\n\t\tres.charactersAdded.unshift(0);\n\t\treturn res.charactersAddedCumulative.unshift(0);\n\t}\n\n\tif (res.content.indexOf(\"<\") === -1 && res.content.indexOf(\">\") === -1) {\n\t\tres.content.replace(/^()([^<>]*)$/, replacerUnshift);\n\t}\n\n\tvar r = new RegExp(\"^()([^<]+)</(?:\" + res.tagsXmlArrayJoined + \")>\");\n\tres.content.replace(r, replacerUnshift);\n\n\tfunction replacerPush() {\n\t\tvar pn = { array: Array.prototype.slice.call(arguments) };\n\t\tpn.array.pop();\n\t\tvar offset = pn.array.pop();\n\t\tpn.offset = offset;\n\t\tpn.last = true;\n\t\t// add at the end\n\t\tres.matches.push(pn);\n\t\tres.charactersAdded.push(0);\n\t\treturn res.charactersAddedCumulative.push(0);\n\t}\n\n\tr = new RegExp(\"(<(?:\" + res.tagsXmlArrayJoined + \")[^>]*>)([^>]+)$\");\n\tres.content.replace(r, replacerPush);\n\treturn res;\n}\n\nfunction xmlMatcher(content, tagsXmlArray) {\n\tvar res = {};\n\tres.content = content;\n\tres.tagsXmlArray = tagsXmlArray;\n\tres.tagsXmlArrayJoined = res.tagsXmlArray.join(\"|\");\n\tvar regexp = new RegExp(\"(<(?:\" + res.tagsXmlArrayJoined + \")[^>]*>)([^<>]*)</(?:\" + res.tagsXmlArrayJoined + \")>\", \"g\");\n\tres.matches = DocUtils.pregMatchAll(regexp, res.content);\n\tres.charactersAddedCumulative = res.matches.map(function () {\n\t\treturn 0;\n\t});\n\tres.charactersAdded = res.matches.map(function () {\n\t\treturn 0;\n\t});\n\treturn handleRecursiveCase(res);\n}\n\nvar memoized = memoize(xmlMatcher);\n\nmodule.exports = function (content, tagsXmlArray) {\n\treturn DocUtils.cloneDeep(memoized(content, tagsXmlArray));\n};","/home/travis/build/npmtest/node-npmtest-docxtemplater/node_modules/docxtemplater/js/lexer.js":"\"use strict\";\n\nvar Errors = require(\"./errors\");\nvar DocUtils = require(\"./doc-utils\");\n\nfunction inRange(range, match) {\n\treturn range[0] <= match.offset && match.offset < range[1];\n}\n\nfunction updateInTextTag(part, inTextTag) {\n\tif (part.type === \"tag\" && part.position === \"start\" && part.text) {\n\t\tif (inTextTag) {\n\t\t\tthrow new Error(\"Malformed xml : Already in text tag\");\n\t\t}\n\t\treturn true;\n\t}\n\tif (part.type === \"tag\" && part.position === \"end\" && part.text) {\n\t\tif (!inTextTag) {\n\t\t\tthrow new Error(\"Malformed xml : Already not in text tag\");\n\t\t}\n\t\treturn false;\n\t}\n\treturn inTextTag;\n}\n\nfunction offsetSort(a, b) {\n\treturn a.offset - b.offset;\n}\n\nfunction getTag(tag) {\n\tvar start = 1;\n\tif (tag[1] === \"/\") {\n\t\tstart = 2;\n\t}\n\tvar index = tag.indexOf(\" \");\n\tvar end = index === -1 ? tag.length - 1 : index;\n\treturn {\n\t\ttag: tag.slice(start, end),\n\t\tposition: start === 1 ? \"start\" : \"end\"\n\t};\n}\n\nfunction tagMatcher(content, textMatchArray, othersMatchArray) {\n\tvar cursor = 0;\n\tvar contentLength = content.length;\n\tvar allMatches = DocUtils.concatArrays([textMatchArray.map(function (tag) {\n\t\treturn { tag: tag, text: true };\n\t}), othersMatchArray.map(function (tag) {\n\t\treturn { tag: tag, text: false };\n\t})]).reduce(function (allMatches, t) {\n\t\tallMatches[t.tag] = t.text;\n\t\treturn allMatches;\n\t}, {});\n\tvar totalMatches = [];\n\n\twhile (cursor < contentLength) {\n\t\tcursor = content.indexOf(\"<\", cursor);\n\t\tif (cursor === -1) {\n\t\t\tbreak;\n\t\t}\n\t\tvar offset = cursor;\n\t\tcursor = content.indexOf(\">\", cursor);\n\t\tvar tagText = content.slice(offset, cursor + 1);\n\n\t\tvar _getTag = getTag(tagText),\n\t\t    tag = _getTag.tag,\n\t\t    position = _getTag.position;\n\n\t\tvar text = allMatches[tag];\n\t\tif (text == null) {\n\t\t\tcontinue;\n\t\t}\n\t\ttotalMatches.push({ type: \"tag\", position: position, text: text, offset: offset, value: tagText });\n\t}\n\n\treturn totalMatches;\n}\n\nfunction throwUnopenedTagException(options) {\n\tvar err = new Errors.XTTemplateError(\"Unopened tag\");\n\terr.properties = {\n\t\txtag: options.xtag.split(\" \")[0],\n\t\tid: \"unopened_tag\",\n\t\tcontext: options.xtag,\n\t\texplanation: \"The tag beginning with '\" + options.xtag.substr(0, 10) + \"' is unclosed\"\n\t};\n\tthrow err;\n}\n\nfunction throwUnclosedTagException(options) {\n\tvar err = new Errors.XTTemplateError(\"Unclosed tag\");\n\terr.properties = {\n\t\txtag: options.xtag.split(\" \")[0].substr(1),\n\t\tid: \"unclosed_tag\",\n\t\tcontext: options.xtag,\n\t\texplanation: \"The tag beginning with '\" + options.xtag.substr(0, 10) + \"' is unclosed\"\n\t};\n\tthrow err;\n}\n\nfunction assertDelimiterOrdered(delimiterMatches, fullText) {\n\tvar inDelimiter = false;\n\tvar lastDelimiterMatch = { offset: 0 };\n\tvar xtag = void 0;\n\tdelimiterMatches.forEach(function (delimiterMatch) {\n\t\txtag = fullText.substr(lastDelimiterMatch.offset, delimiterMatch.offset - lastDelimiterMatch.offset);\n\t\tif (delimiterMatch.position === \"start\" && inDelimiter || delimiterMatch.position === \"end\" && !inDelimiter) {\n\t\t\tif (delimiterMatch.position === \"start\") {\n\t\t\t\tthrowUnclosedTagException({ xtag: xtag });\n\t\t\t} else {\n\t\t\t\tthrowUnopenedTagException({ xtag: xtag });\n\t\t\t}\n\t\t}\n\t\tinDelimiter = !inDelimiter;\n\t\tlastDelimiterMatch = delimiterMatch;\n\t});\n\tvar delimiterMatch = { offset: fullText.length };\n\txtag = fullText.substr(lastDelimiterMatch.offset, delimiterMatch.offset - lastDelimiterMatch.offset);\n\tif (inDelimiter) {\n\t\tthrowUnclosedTagException({ xtag: xtag });\n\t}\n}\n\nfunction getAllIndexes(arr, val, position) {\n\tvar indexes = [];\n\tvar offset = -1;\n\tdo {\n\t\toffset = arr.indexOf(val, offset + 1);\n\t\tif (offset !== -1) {\n\t\t\tindexes.push({ offset: offset, position: position });\n\t\t}\n\t} while (offset !== -1);\n\treturn indexes;\n}\n\nfunction Reader(innerContentParts) {\n\tvar _this = this;\n\n\tthis.innerContentParts = innerContentParts;\n\tthis.full = \"\";\n\tthis.parseDelimiters = function (delimiters) {\n\t\t_this.full = _this.innerContentParts.join(\"\");\n\t\tvar offset = 0;\n\t\t_this.ranges = _this.innerContentParts.map(function (part) {\n\t\t\toffset += part.length;\n\t\t\treturn offset - part.length;\n\t\t});\n\n\t\tvar delimiterMatches = DocUtils.concatArrays([getAllIndexes(_this.full, delimiters.start, \"start\"), getAllIndexes(_this.full, delimiters.end, \"end\")]).sort(offsetSort);\n\t\tassertDelimiterOrdered(delimiterMatches, _this.full);\n\t\tvar delimiterLength = { start: delimiters.start.length, end: delimiters.end.length };\n\t\tvar cutNext = 0;\n\t\tvar delimiterIndex = 0;\n\n\t\t_this.parsed = _this.ranges.map(function (offset, i) {\n\t\t\tvar range = [offset, offset + this.innerContentParts[i].length];\n\t\t\tvar partContent = this.innerContentParts[i];\n\t\t\tvar delimitersInOffset = [];\n\t\t\twhile (delimiterIndex < delimiterMatches.length && inRange(range, delimiterMatches[delimiterIndex])) {\n\t\t\t\tdelimitersInOffset.push(delimiterMatches[delimiterIndex]);\n\t\t\t\tdelimiterIndex++;\n\t\t\t}\n\t\t\tvar parts = [];\n\t\t\tvar cursor = 0;\n\t\t\tif (cutNext > 0) {\n\t\t\t\tcursor = cutNext;\n\t\t\t\tcutNext = 0;\n\t\t\t}\n\t\t\tdelimitersInOffset.forEach(function (delimiterInOffset) {\n\t\t\t\tvar value = partContent.substr(cursor, delimiterInOffset.offset - offset - cursor);\n\t\t\t\tif (value.length > 0) {\n\t\t\t\t\tparts.push({ type: \"content\", value: value });\n\t\t\t\t}\n\t\t\t\tparts.push({ type: \"delimiter\", position: delimiterInOffset.position });\n\t\t\t\tcursor = delimiterInOffset.offset - offset + delimiterLength[delimiterInOffset.position];\n\t\t\t});\n\t\t\tcutNext = cursor - partContent.length;\n\t\t\tvar value = partContent.substr(cursor);\n\t\t\tif (value.length > 0) {\n\t\t\t\tparts.push({ type: \"content\", value: value });\n\t\t\t}\n\t\t\treturn parts;\n\t\t}, _this);\n\t};\n}\n\nmodule.exports = {\n\tparse: function parse(xmlparsed, delimiters) {\n\t\tvar inTextTag = false;\n\t\tvar innerContentParts = [];\n\t\txmlparsed.forEach(function (part) {\n\t\t\tinTextTag = updateInTextTag(part, inTextTag);\n\t\t\tif (inTextTag && part.type === \"content\") {\n\t\t\t\tinnerContentParts.push(part.value);\n\t\t\t}\n\t\t});\n\t\tvar reader = new Reader(innerContentParts);\n\t\treader.parseDelimiters(delimiters);\n\n\t\tvar newArray = [];\n\t\tvar index = 0;\n\t\txmlparsed.forEach(function (part) {\n\t\t\tinTextTag = updateInTextTag(part, inTextTag);\n\t\t\tif (part.type === \"content\") {\n\t\t\t\tpart.position = inTextTag ? \"insidetag\" : \"outsidetag\";\n\t\t\t}\n\t\t\tif (inTextTag && part.type === \"content\") {\n\t\t\t\tArray.prototype.push.apply(newArray, reader.parsed[index].map(function (p) {\n\t\t\t\t\tif (p.type === \"content\") {\n\t\t\t\t\t\tp.position = \"insidetag\";\n\t\t\t\t\t}\n\t\t\t\t\treturn p;\n\t\t\t\t}));\n\t\t\t\tindex++;\n\t\t\t} else {\n\t\t\t\tnewArray.push(part);\n\t\t\t}\n\t\t});\n\t\treturn newArray;\n\t},\n\txmlparse: function xmlparse(content, xmltags) {\n\t\tvar matches = tagMatcher(content, xmltags.text, xmltags.other);\n\t\tvar cursor = 0;\n\t\tvar parsed = matches.reduce(function (parsed, match) {\n\t\t\tvar value = content.substr(cursor, match.offset - cursor);\n\t\t\tif (value.length > 0) {\n\t\t\t\tparsed.push({ type: \"content\", value: value });\n\t\t\t}\n\t\t\tcursor = match.offset + match.value.length;\n\t\t\tdelete match.offset;\n\t\t\tif (match.value.length > 0) {\n\t\t\t\tparsed.push(match);\n\t\t\t}\n\t\t\treturn parsed;\n\t\t}, []);\n\t\tvar value = content.substr(cursor);\n\t\tif (value.length > 0) {\n\t\t\tparsed.push({ type: \"content\", value: value });\n\t\t}\n\t\treturn parsed;\n\t}\n};","/home/travis/build/npmtest/node-npmtest-docxtemplater/node_modules/docxtemplater/js/parser.js":"\"use strict\";\n\nvar DocUtils = require(\"./doc-utils\");\n\nvar parser = {\n\tpostparse: function postparse(parsed, modules) {\n\t\tfunction getTraits(traitName, parsed) {\n\t\t\treturn modules.map(function (module) {\n\t\t\t\treturn module.getTraits(traitName, parsed);\n\t\t\t});\n\t\t}\n\t\tfunction postparse(parsed) {\n\t\t\treturn modules.reduce(function (parsed, module) {\n\t\t\t\treturn module.postparse(parsed, { postparse: postparse, getTraits: getTraits });\n\t\t\t}, parsed);\n\t\t}\n\t\treturn postparse(parsed);\n\t},\n\tparse: function parse(lexed, modules) {\n\t\tfunction moduleParse(placeHolderContent, parsed) {\n\t\t\tvar moduleParsed = void 0;\n\t\t\tfor (var i = 0, l = modules.length; i < l; i++) {\n\t\t\t\tvar _module = modules[i];\n\t\t\t\tmoduleParsed = _module.parse(placeHolderContent);\n\t\t\t\tif (moduleParsed) {\n\t\t\t\t\tparsed.push(moduleParsed);\n\t\t\t\t\treturn moduleParsed;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\tvar inPlaceHolder = false;\n\t\tvar placeHolderContent = void 0;\n\t\tvar tailParts = [];\n\t\treturn lexed.reduce(function (parsed, token) {\n\t\t\tif (token.type === \"delimiter\") {\n\t\t\t\tinPlaceHolder = token.position === \"start\";\n\t\t\t\tif (token.position === \"end\") {\n\t\t\t\t\tplaceHolderContent = DocUtils.wordToUtf8(placeHolderContent);\n\t\t\t\t\tif (!moduleParse(placeHolderContent, parsed)) {\n\t\t\t\t\t\tparsed.push({ type: \"placeholder\", value: placeHolderContent });\n\t\t\t\t\t}\n\t\t\t\t\tArray.prototype.push.apply(parsed, tailParts);\n\t\t\t\t\ttailParts = [];\n\t\t\t\t\treturn parsed;\n\t\t\t\t}\n\t\t\t\tplaceHolderContent = \"\";\n\t\t\t\treturn parsed;\n\t\t\t}\n\t\t\tif (inPlaceHolder) {\n\t\t\t\tif (token.type === \"content\" && token.position === \"insidetag\") {\n\t\t\t\t\tplaceHolderContent += token.value;\n\t\t\t\t} else {\n\t\t\t\t\ttailParts.push(token);\n\t\t\t\t}\n\t\t\t\treturn parsed;\n\t\t\t}\n\t\t\tparsed.push(token);\n\t\t\treturn parsed;\n\t\t}, []);\n\t}\n};\n\nmodule.exports = parser;","/home/travis/build/npmtest/node-npmtest-docxtemplater/node_modules/docxtemplater/js/render.js":"\"use strict\";\n\nvar ScopeManager = require(\"./scope-manager\");\nvar DocUtils = require(\"./doc-utils\");\n\nfunction moduleRender(part, options) {\n\tvar moduleRendered = void 0;\n\tfor (var i = 0, l = options.modules.length; i < l; i++) {\n\t\tvar _module = options.modules[i];\n\t\tmoduleRendered = _module.render(part, options);\n\t\tif (moduleRendered) {\n\t\t\treturn moduleRendered;\n\t\t}\n\t}\n\treturn false;\n}\n\nfunction render(options) {\n\toptions.render = render;\n\toptions.modules = options.modules;\n\tif (!options.scopeManager) {\n\t\toptions.scopeManager = ScopeManager.createBaseScopeManager(options);\n\t}\n\treturn options.compiled.map(function (part) {\n\t\tvar moduleRendered = moduleRender(part, options);\n\t\tif (moduleRendered) {\n\t\t\treturn moduleRendered.value;\n\t\t}\n\t\tif (part.type === \"placeholder\") {\n\t\t\tvar value = options.scopeManager.getValue(part.value);\n\t\t\tif (value == null) {\n\t\t\t\tvalue = options.nullGetter(part);\n\t\t\t}\n\t\t\treturn DocUtils.utf8ToWord(value);\n\t\t}\n\t\tif (part.type === \"content\" || part.type === \"tag\") {\n\t\t\treturn part.value;\n\t\t}\n\t\tthrow new Error(\"Unimplemented tag type \\\"\" + part.type + \"\\\"\");\n\t}).join(\"\");\n}\n\nmodule.exports = render;","/home/travis/build/npmtest/node-npmtest-docxtemplater/node_modules/docxtemplater/js/file-type-config.js":"\"use strict\";\n\nvar loopModule = require(\"./modules/loop\");\nvar spacePreserveModule = require(\"./modules/space-preserve\");\nvar rawXmlModule = require(\"./modules/rawxml\");\nvar expandPairTrait = require(\"./modules/expand-pair-trait\");\nvar render = require(\"./modules/render\");\n\nvar PptXFileTypeConfig = {\n\tgetTemplatedFiles: function getTemplatedFiles(zip) {\n\t\tvar slideTemplates = zip.file(/ppt\\/(slides|slideMasters)\\/(slide|slideMaster)\\d+\\.xml/).map(function (file) {\n\t\t\treturn file.name;\n\t\t});\n\t\treturn slideTemplates.concat([\"ppt/presentation.xml\"]);\n\t},\n\n\ttextPath: \"ppt/slides/slide1.xml\",\n\ttagsXmlTextArray: [\"a:t\", \"m:t\"],\n\ttagsXmlLexedArray: [\"p:sp\", \"a:tc\", \"a:tr\", \"a:table\", \"a:p\", \"a:r\"],\n\ttagRawXml: \"p:sp\",\n\ttagTextXml: \"a:t\",\n\tbaseModules: [render, expandPairTrait, rawXmlModule, loopModule]\n};\n\nvar DocXFileTypeConfig = {\n\tgetTemplatedFiles: function getTemplatedFiles(zip) {\n\t\tvar slideTemplates = zip.file(/word\\/(header|footer)\\d+\\.xml/).map(function (file) {\n\t\t\treturn file.name;\n\t\t});\n\t\treturn slideTemplates.concat([\"word/document.xml\"]);\n\t},\n\n\ttextPath: \"word/document.xml\",\n\ttagsXmlTextArray: [\"w:t\", \"m:t\"],\n\ttagsXmlLexedArray: [\"w:tc\", \"w:tr\", \"w:table\", \"w:p\", \"w:r\"],\n\ttagRawXml: \"w:p\",\n\ttagTextXml: \"w:t\",\n\tbaseModules: [render, spacePreserveModule, expandPairTrait, rawXmlModule, loopModule]\n};\n\nmodule.exports = {\n\tdocx: DocXFileTypeConfig,\n\tpptx: PptXFileTypeConfig\n};","/home/travis/build/npmtest/node-npmtest-docxtemplater/node_modules/docxtemplater/js/modules/loop.js":"\"use strict\";\n\nvar DocUtils = require(\"../doc-utils\");\nvar dashInnerRegex = /^-([^\\s]+)\\s(.+)$/;\nvar wrapper = require(\"../module-wrapper\");\n\nvar moduleName = \"loop\";\n\nvar loopModule = {\n\tname: \"LoopModule\",\n\tparse: function parse(placeHolderContent) {\n\t\tvar module = moduleName;\n\t\tvar type = \"placeholder\";\n\t\tif (placeHolderContent[0] === \"#\") {\n\t\t\treturn { type: type, value: placeHolderContent.substr(1), expandTo: \"auto\", module: module, location: \"start\", inverted: false };\n\t\t}\n\t\tif (placeHolderContent[0] === \"^\") {\n\t\t\treturn { type: type, value: placeHolderContent.substr(1), expandTo: \"auto\", module: module, location: \"start\", inverted: true };\n\t\t}\n\t\tif (placeHolderContent[0] === \"/\") {\n\t\t\treturn { type: type, value: placeHolderContent.substr(1), module: module, location: \"end\" };\n\t\t}\n\t\tif (placeHolderContent[0] === \"-\") {\n\t\t\tvar value = placeHolderContent.replace(dashInnerRegex, \"$2\");\n\t\t\tvar expandTo = placeHolderContent.replace(dashInnerRegex, \"$1\");\n\t\t\treturn { type: type, value: value, expandTo: expandTo, module: module, location: \"start\", inverted: false };\n\t\t}\n\t\treturn null;\n\t},\n\tgetTraits: function getTraits(traitName, parsed) {\n\t\tif (traitName !== \"expandPair\") {\n\t\t\treturn;\n\t\t}\n\n\t\treturn parsed.reduce(function (tags, part, offset) {\n\t\t\tif (part.type === \"placeholder\" && part.module === moduleName) {\n\t\t\t\ttags.push({ part: part, offset: offset });\n\t\t\t}\n\t\t\treturn tags;\n\t\t}, []);\n\t},\n\trender: function render(part, options) {\n\t\tif (!part.type === \"placeholder\" || part.module !== moduleName) {\n\t\t\treturn null;\n\t\t}\n\t\tvar totalValue = [];\n\t\tfunction loopOver(scope) {\n\t\t\tvar scopeManager = options.scopeManager.createSubScopeManager(scope, part.value);\n\t\t\ttotalValue.push(options.render(DocUtils.mergeObjects({}, options, {\n\t\t\t\tcompiled: part.subparsed,\n\t\t\t\ttags: {},\n\t\t\t\tscopeManager: scopeManager\n\t\t\t})));\n\t\t}\n\t\toptions.scopeManager.loopOver(part.value, loopOver, part.inverted);\n\t\treturn { value: totalValue.join(\"\") };\n\t}\n};\n\nmodule.exports = function () {\n\treturn wrapper(loopModule);\n};","/home/travis/build/npmtest/node-npmtest-docxtemplater/node_modules/docxtemplater/js/modules/space-preserve.js":"\"use strict\";\n\nvar wrapper = require(\"../module-wrapper\");\nvar spacePreserve = {\n\tname: \"SpacePreserveModule\",\n\tpostparse: function postparse(parsed) {\n\t\tvar chunk = [];\n\t\tvar inChunk = false;\n\t\tvar result = parsed.reduce(function (parsed, part) {\n\t\t\tif (part.type === \"tag\" && part.position === \"start\" && part.text && part.value === \"<w:t>\") {\n\t\t\t\tinChunk = true;\n\t\t\t}\n\t\t\tif (inChunk) {\n\t\t\t\tif (part.type === \"placeholder\" && !part.module) {\n\t\t\t\t\tchunk[0].value = '<w:t xml:space=\"preserve\">';\n\t\t\t\t}\n\t\t\t\tchunk.push(part);\n\t\t\t} else {\n\t\t\t\tparsed.push(part);\n\t\t\t}\n\t\t\tif (part.type === \"tag\" && part.position === \"end\" && part.text && part.value === \"</w:t>\") {\n\t\t\t\tArray.prototype.push.apply(parsed, chunk);\n\t\t\t\tinChunk = false;\n\t\t\t\tchunk = [];\n\t\t\t}\n\t\t\treturn parsed;\n\t\t}, []);\n\t\tArray.prototype.push.apply(result, chunk);\n\t\treturn result;\n\t}\n};\nmodule.exports = function () {\n\treturn wrapper(spacePreserve);\n};","/home/travis/build/npmtest/node-npmtest-docxtemplater/node_modules/docxtemplater/js/modules/rawxml.js":"\"use strict\";\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar DocUtils = require(\"../doc-utils\");\nvar Errors = require(\"../errors\");\n\nvar moduleName = \"rawxml\";\nvar wrapper = require(\"../module-wrapper\");\n\nfunction throwRawTagShouldBeOnlyTextInParagraph(options) {\n\tvar err = new Errors.XTTemplateError(\"Raw tag should be the only text in paragraph\");\n\tvar tag = options.part.value;\n\terr.properties = {\n\t\tid: \"raw_xml_tag_should_be_only_text_in_paragraph\",\n\t\texplanation: \"The tag \" + tag,\n\t\txtag: options.part.value,\n\t\tparagraphParts: options.paragraphParts\n\t};\n\tthrow err;\n}\n\nfunction getInner(_ref) {\n\tvar part = _ref.part,\n\t    left = _ref.left,\n\t    right = _ref.right,\n\t    postparsed = _ref.postparsed,\n\t    index = _ref.index;\n\n\tvar paragraphParts = postparsed.slice(left + 1, right);\n\tparagraphParts.forEach(function (p, i) {\n\t\tif (i === index - left - 1) {\n\t\t\treturn;\n\t\t}\n\t\tif (p.type === \"placeholder\" || p.type === \"content\" && p.position === \"insidetag\") {\n\t\t\tthrowRawTagShouldBeOnlyTextInParagraph({ paragraphParts: paragraphParts, part: part });\n\t\t}\n\t});\n\treturn part;\n}\n\nvar RawXmlModule = function () {\n\tfunction RawXmlModule() {\n\t\t_classCallCheck(this, RawXmlModule);\n\n\t\tthis.name = \"RawXmlModule\";\n\t}\n\n\t_createClass(RawXmlModule, [{\n\t\tkey: \"optionsTransformer\",\n\t\tvalue: function optionsTransformer(options, docxtemplater) {\n\t\t\tthis.fileTypeConfig = docxtemplater.fileTypeConfig;\n\t\t\treturn options;\n\t\t}\n\t}, {\n\t\tkey: \"parse\",\n\t\tvalue: function parse(placeHolderContent) {\n\t\t\tvar type = \"placeholder\";\n\t\t\tif (placeHolderContent[0] !== \"@\") {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\treturn { type: type, value: placeHolderContent.substr(1), module: moduleName };\n\t\t}\n\t}, {\n\t\tkey: \"postparse\",\n\t\tvalue: function postparse(parsed) {\n\t\t\treturn DocUtils.traits.expandToOne(parsed, { moduleName: moduleName, getInner: getInner, expandTo: this.fileTypeConfig.tagRawXml });\n\t\t}\n\t}, {\n\t\tkey: \"render\",\n\t\tvalue: function render(part, options) {\n\t\t\tif (part.module !== moduleName) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tvar value = options.scopeManager.getValue(part.value);\n\t\t\tif (value == null) {\n\t\t\t\tvalue = options.nullGetter(part);\n\t\t\t}\n\t\t\treturn { value: value };\n\t\t}\n\t}]);\n\n\treturn RawXmlModule;\n}();\n\nmodule.exports = function () {\n\treturn wrapper(new RawXmlModule());\n};","/home/travis/build/npmtest/node-npmtest-docxtemplater/node_modules/docxtemplater/js/modules/expand-pair-trait.js":"\"use strict\";\n\nvar traitName = \"expandPair\";\nvar mergeSort = require(\"../mergesort\");\nvar DocUtils = require(\"../doc-utils\");\nvar wrapper = require(\"../module-wrapper\");\n\nvar _require = require(\"../traits\"),\n    getExpandToDefault = _require.getExpandToDefault;\n\nvar Errors = require(\"../errors\");\n\nfunction throwUnmatchedLoopException(options) {\n\tvar location = options.location;\n\tvar t = location === \"start\" ? \"unclosed\" : \"unopened\";\n\tvar T = location === \"start\" ? \"Unclosed\" : \"Unopened\";\n\n\tvar err = new Errors.XTTemplateError(T + \" loop\");\n\tvar tag = options.part.value;\n\terr.properties = {\n\t\tid: t + \"_loop\",\n\t\texplanation: \"The loop with tag \" + tag + \" is \" + t,\n\t\txtag: tag\n\t};\n\tthrow err;\n}\n\nfunction throwClosingTagNotMatchOpeningTag(options) {\n\tvar tags = options.tags;\n\n\tvar err = new Errors.XTTemplateError(\"Closing tag does not match opening tag\");\n\terr.properties = {\n\t\tid: \"closing_tag_does_not_match_opening_tag\",\n\t\texplanation: \"The tag \\\"\" + tags[0].value + \"\\\" is closed by the tag \\\"\" + tags[1].value + \"\\\"\",\n\t\topeningtag: tags[0].value,\n\t\tclosingtag: tags[1].value\n\t};\n\tthrow err;\n}\n\nfunction getOpenCountChange(part) {\n\tswitch (part.location) {\n\t\tcase \"start\":\n\t\t\treturn 1;\n\t\tcase \"end\":\n\t\t\treturn -1;\n\t\tdefault:\n\t\t\tthrow new Error(\"Location should be one of 'start' or 'end' (given : \" + part.location + \")\");\n\t}\n}\n\nfunction getPairs(traits) {\n\tif (traits.length === 0) {\n\t\treturn [];\n\t}\n\tvar countOpen = 1;\n\tvar firstTrait = traits[0];\n\tfor (var i = 1; i < traits.length; i++) {\n\t\tvar currentTrait = traits[i];\n\t\tcountOpen += getOpenCountChange(currentTrait.part);\n\t\tif (countOpen === 0) {\n\t\t\tif (currentTrait.part.value !== firstTrait.part.value && currentTrait.part.value !== \"\") {\n\t\t\t\tthrowClosingTagNotMatchOpeningTag({ tags: [firstTrait.part, currentTrait.part] });\n\t\t\t}\n\t\t\tvar outer = getPairs(traits.slice(i + 1));\n\t\t\treturn [[firstTrait, currentTrait]].concat(outer);\n\t\t}\n\t}\n\tvar part = firstTrait.part;\n\tthrowUnmatchedLoopException({ part: part, location: part.location });\n}\n\nvar expandPairTrait = {\n\tname: \"ExpandPairTrait\",\n\tpostparse: function postparse(parsed, _ref) {\n\t\tvar getTraits = _ref.getTraits,\n\t\t    _postparse = _ref.postparse;\n\n\t\tvar traits = getTraits(traitName, parsed);\n\t\ttraits = traits.map(function (trait) {\n\t\t\treturn trait || [];\n\t\t});\n\t\ttraits = mergeSort(traits);\n\t\tvar pairs = getPairs(traits);\n\t\tvar expandedPairs = pairs.map(function (pair) {\n\t\t\tvar expandTo = pair[0].part.expandTo;\n\t\t\tif (expandTo === \"auto\") {\n\t\t\t\texpandTo = getExpandToDefault(parsed.slice(pair[0].offset, pair[1].offset));\n\t\t\t}\n\t\t\tif (!expandTo) {\n\t\t\t\treturn [pair[0].offset, pair[1].offset];\n\t\t\t}\n\t\t\tvar left = DocUtils.getLeft(parsed, expandTo, pair[0].offset);\n\t\t\tvar right = DocUtils.getRight(parsed, expandTo, pair[1].offset);\n\t\t\treturn [left, right];\n\t\t});\n\n\t\tvar currentPairIndex = 0;\n\t\tvar innerParts = void 0;\n\t\treturn parsed.reduce(function (newParsed, part, i) {\n\t\t\tvar inPair = currentPairIndex < pairs.length && expandedPairs[currentPairIndex][0] <= i;\n\t\t\tvar pair = pairs[currentPairIndex];\n\t\t\tvar expandedPair = expandedPairs[currentPairIndex];\n\t\t\tif (!inPair) {\n\t\t\t\tnewParsed.push(part);\n\t\t\t\treturn newParsed;\n\t\t\t}\n\t\t\tif (expandedPair[0] === i) {\n\t\t\t\tinnerParts = [];\n\t\t\t}\n\t\t\tif (pair[0].offset !== i && pair[1].offset !== i) {\n\t\t\t\tinnerParts.push(part);\n\t\t\t}\n\t\t\tif (expandedPair[1] === i) {\n\t\t\t\tvar basePart = parsed[pair[0].offset];\n\t\t\t\tdelete basePart.location;\n\t\t\t\tdelete basePart.expandTo;\n\t\t\t\tbasePart.subparsed = _postparse(innerParts);\n\t\t\t\tnewParsed.push(basePart);\n\t\t\t\tcurrentPairIndex++;\n\t\t\t}\n\t\t\treturn newParsed;\n\t\t}, []);\n\t}\n};\n\nmodule.exports = function () {\n\treturn wrapper(expandPairTrait);\n};","/home/travis/build/npmtest/node-npmtest-docxtemplater/node_modules/docxtemplater/js/mergesort.js":"\"use strict\";\n\nfunction getMinFromArrays(arrays, state) {\n\tvar minIndex = -1;\n\tfor (var i = 0, l = arrays.length; i < l; i++) {\n\t\tif (state[i] >= arrays[i].length) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (minIndex === -1 || arrays[i][state[i]].offset < arrays[minIndex][state[minIndex]].offset) {\n\t\t\tminIndex = i;\n\t\t}\n\t}\n\tif (minIndex === -1) {\n\t\tthrow new Error(\"minIndex negative\");\n\t}\n\treturn minIndex;\n}\n\nmodule.exports = function (arrays) {\n\tvar totalLength = arrays.reduce(function (sum, array) {\n\t\treturn sum + array.length;\n\t}, 0);\n\tarrays = arrays.filter(function (array) {\n\t\treturn array.length > 0;\n\t});\n\n\tvar resultArray = new Array(totalLength);\n\n\tvar state = arrays.map(function () {\n\t\treturn 0;\n\t});\n\n\tvar i = 0;\n\n\twhile (i <= totalLength - 1) {\n\t\tvar arrayIndex = getMinFromArrays(arrays, state);\n\t\tresultArray[i] = arrays[arrayIndex][state[arrayIndex]];\n\t\tstate[arrayIndex]++;\n\t\ti++;\n\t}\n\n\treturn resultArray;\n};","/home/travis/build/npmtest/node-npmtest-docxtemplater/node_modules/docxtemplater/js/modules/render.js":"\"use strict\";\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar wrapper = require(\"../module-wrapper\");\n\nvar Render = function () {\n\tfunction Render() {\n\t\t_classCallCheck(this, Render);\n\n\t\tthis.name = \"Render\";\n\t}\n\n\t_createClass(Render, [{\n\t\tkey: \"set\",\n\t\tvalue: function set(obj) {\n\t\t\tif (obj.compiled) {\n\t\t\t\tthis.compiled = obj.compiled;\n\t\t\t}\n\t\t\tif (obj.data != null) {\n\t\t\t\tthis.data = obj.data;\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: \"getRenderedMap\",\n\t\tvalue: function getRenderedMap(mapper) {\n\t\t\tvar _this = this;\n\n\t\t\treturn Object.keys(this.compiled).reduce(function (mapper, from) {\n\t\t\t\tmapper[from] = { from: from, data: _this.data };\n\t\t\t\treturn mapper;\n\t\t\t}, mapper);\n\t\t}\n\t}]);\n\n\treturn Render;\n}();\n\nmodule.exports = function () {\n\treturn wrapper(new Render());\n};"}